# 优化订单查询记录

### 语句的优化-1

偶然的机会，接到一个订单查询相关的任务，调试的时候发现平台的订单查询突然变慢了很多，突然，意味着有问题。调试排查，发现sql语句存在问题。

查了git日志，没有人改动代码，然后去分析语句发现居然是使用主键索引，非常可怕。原来订单的数据量上升到一个等级了，对于原有的sql语句，mysql优化器认为排序的成本比较高，于是选择了便于排序的访问路径，
在索引书籍里可以称之为**候选二**。但是这个成本是非常昂贵的，事实证明，优化器做了一件蠢事。
而我们需要做的就是引导优化器去选择正确的访问路径。
以下是部分代码：

- 优化前

```javascript

select distinct(s.id),s.ordernum  from t1 s  join t2 os on s.ordernum=os.orderid 
where 1=1 and ordertime>='2017-05-04 00:00:00' and ordertime<='2017-05-04 23:59:59' 
and (os.sellerid=3385 or os.buyerid=3385 AND os.id>0)  order by id desc limit 0,15

```

- 优化后

```javascript

select distinct(s.id), s.ordernum  from t1 s  join t2 os on s.ordernum=os.orderid  where 1=1 
and ordertime>='2017-05-04 00:00:00' and ordertime<='2017-05-04 23:59:59' 
and (os.sellerid=3385 or os.buyerid=3385 AND os.id>0)  order by s.ordertime desc limit 0,15

```

### 逻辑的优化

后来去重构逻辑的代码时发现，平台的订单查询导出又突然变慢了很多很多。三个月的订单导出，居然需要一分三十几秒，从客户的角度出发，这是非常难以忍受的。排查发现，一个同事新加了一个业务逻辑，
每个订单都需要判断一次。根据订单数据的异同，每个订单的判断需要0.009s~0.03s，最坏的情况 0.03*7000个订单=？秒。由此可见，单个量不是问题，问题是多个累加。
实际上导出订单的业务逻辑不需要该判断，去掉以后，订单的导出快了很多。

- 所以，对于量大的循环，最好不要去做单个非内存操作；


### 语句的优化-2

在1的基础上，最近测试重构后的性能又发现新的问题，如果t1表的索引切片太大，或者没有用到索引，那么优化器将以t2表作为主表，因为检索的条目更少；使用index_merge还能接受，但随着而来的是临时表和磁盘排序，
恰恰这个是比较昂贵的，随机IO飙升，优化器又一次做出错误的抉择。
暂时优化的方法：结合业务逻辑，根据t1表不同的谓语，force不同的index；后续还有一些难题待方案优化，待续......