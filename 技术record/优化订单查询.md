# 优化订单查询记录

### 语句的优化-1

偶然的机会，我接到一个订单查询相关的任务，然后发现平台的订单查询突然变慢了很多，突然，意味着有问题。经过排查，发现原有的sql语句存在问题。

查了git日志，发现没有人改动代码，然后取分析语句发现居然是使用主键索引，非常可怕。原来是订单的数据量上升到一个等级了，对于原有的sql语句，mysql优化器认为排序的成本比较高，于是选择了便于排序的访问路径，在索引书籍里可以称之为**候选二**。但是这个成本是非常昂贵的，事实证明，优化器又一次做了一件蠢事。
而我们需要做的就是引导优化器去选择正确的访问路径。
以下是部分代码：

- 优化前

```javascript
select distinct(s.id),s.ordernum  from t1 s  join t2 os on s.ordernum=os.orderid 
where 1=1 and ordertime>='2017-05-04 00:00:00' and ordertime<='2017-05-04 23:59:59' and (os.sellerid=3385 or os.buyerid=3385 AND os.id>0)  order by id desc limit 0,15
```

- 优化后

```javascript
select s.id, s.ordernum  from t1 s  join t2 os on s.ordernum=os.orderid  where 1=1 and ordertime>='2017-05-04 00:00:00' and ordertime<='2017-05-04 23:59:59' and (os.sellerid=3385 or os.buyerid=3385 AND os.id>0)  order by s.ordertime desc limit 0,15
```

### 逻辑的优化

后来去重构逻辑的代码时发现，平台的订单查询导出又突然变慢了很多很多。三个月的订单导出，居然需要一分三十几秒，如果我是客户，这是非常难以忍受的。经过排查发现，敢情是我主管干的好事。
他新加了一个业务逻辑，每个订单都需要判断一次。根据订单数据的异同，每个订单的判断需要0.009s~0.03s，最坏的情况 0.03*7000个订单=？秒。由此可见，单个量不是问题，问题是多个累加。
经过询问，发现订单查询并不需要该判断。去掉以后，订单的导出快了很多。

- 所以，对于量大的循环，最好不要去做单个非内存操作；


### 语句的优化-2

在1的基础上，最近又发现新的问题，如果t1的索引切片太大，或者没有用到索引，那么优化器将以t2作为主表，因为检索的条目更少，使用index_merge还能接受，但随着而来的是临时表和磁盘排序，恰恰这个是比较昂贵的，优化器又一次做出错误的抉择。
结合业务逻辑，根据t1不同的谓语，force不同的index；后续还有一些难题待方案优化，待续......