##### 硬件基础假设
- 随机读：10ms
- 顺序读：40MB/s
- 检查一行: 5us
- FETCH: 100us

##### 不合适的索引
- 语句：````SELECT id,FNAME FROM CUST WHERE LNAME=:LNAME AND CITY=:CITY ORDER BY FNAME````
- 索引：udx:LNAME,FNAME
- 过程
    1. 根据LNAME=:LNAME扫描索引切片，对于每一行，都要回表校验CITY字段，随机IO 10000 * 10ms = 100s
- 全表扫描
    1. 一次随机IO+600MB/40MB/s = 10ms + 15s,由于排序，该方案的CPU时间很多
    
##### 三星索引
- 一次查询通常只需要一次随机IO以及一次窄索引片扫描
- 查询相关的索引行相邻，或者相距足够靠近，第一颗星
- 索引行的顺序与查询语句的需求一致，第二颗星
- 索引行包含查询语句所有的列，第三颗星（包含第三颗星的，称为宽索引）
- 满足第一颗星：等值谓词的列，任意顺序作为索引的开头
- 满足第二颗星：将ORDER BY列加入索引中，不改变顺序
- 满足第三颗星：将查询语句中剩余的列加到索引中，将易变的列放到最后以降低更新成本

##### 谓词范围和三星索引
- 有非等值谓语时，不能同时拥有三颗星
    1. 避免排序，拥有第二颗星
    2. 拥有可能的最窄索引片，拥有第一颗星（通常第一颗星比第二颗星重要）
    
##### 为查询语句设计最佳索引的算法
- 候选A
    1. 取出不过分复杂的等值谓词作为索引的前导列，任意顺序
    2. 将选择性最好的的谓词范围作为索引的下一列，如果存在！
    3. 以正确顺序添加ORDER BY列
    4. 以任意顺序将SELECT语句中其余的列添加到索引中
- 候选B（在候选A可能引起一次排序操作的情况下）
    1. 取出不过分复杂的等值谓词作为索引的前导列，任意顺序
    2. 以正确顺序添加ORDER BY列
    3. 以任意顺序将SELECT语句中其余的列添加到索引中
    
##### 新增一个索引的代价
- 响应时间
    1. 在一个索引上添加一行，耗费10ms，随机IO一次叶子页
    2. 前提：10个索引的表，插入20行，181次随机IO；新的索引行把表上的一个索引添加到同一个叶子页上，把其余9个索引添加到20个不同的叶子页上
- 磁盘负载
    1. 数据库是异步写，不影响响应时间，但增加磁盘负载
    2. 每次页更新，引起两个磁盘的访问，每次访问12ms，共24ms
    3. 平均磁盘负载不应超过25%
    4. 如果磁盘负载成为问题，比较明显的解决办法是尝试合并索引，一个有10个列的索引比两个各有6个列的索引引起的磁盘负载要小
    
##### 一些建议
- 机械性地为每一个查询设计最佳索引是不明智的
- 实际情况是针对那些不合适的索引设计而导致速度太慢的查询语句进行索引设计

